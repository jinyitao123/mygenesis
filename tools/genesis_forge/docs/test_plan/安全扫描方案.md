这是一个针对 **Project Genesis** 的 Text-to-Cypher 模块（以及潜在的参数注入漏洞）设计的安全扫描方案。

该方案包含一个结构化的 **恶意指令集 (Malicious Payloads)** 和一个自动化的 **安全扫描器脚本 (Security Scanner)**。

---

### 1. 恶意指令集定义 (security_payloads.json)

请将此文件保存为 `tests/security/security_payloads.json`。该数据集覆盖了常见的 Cypher 注入、数据破坏和系统探测攻击。

```json
{
  "meta": {
    "version": "1.0",
    "description": "Malicious Cypher payloads for security scanning Genesis Engine."
  },
  "categories": [
    {
      "name": "Cypher Injection - Tautologies",
      "description": "试图绕过逻辑检查（如 Validation 阶段）",
      "payloads": [
        "' OR 1=1 RETURN true //",
        "\" OR 1=1 RETURN true //",
        "1) OR true RETURN true //",
        "' OR '1'='1"
      ]
    },
    {
      "name": "Data Destruction",
      "description": "试图删除节点、关系或清空数据库",
      "payloads": [
        "MATCH (n) DETACH DELETE n",
        "MATCH (n:Player) DELETE n",
        "MATCH (n) REMOVE n:Entity",
        "'; MATCH (n) DETACH DELETE n //",
        "\") DELETE n //"
      ]
    },
    {
      "name": "Data Exfiltration & System Info",
      "description": "试图读取敏感数据或系统配置",
      "payloads": [
        "CALL dbms.components() YIELD name, versions, edition RETURN *",
        "CALL dbms.functions() YIELD name",
        "MATCH (u:User) RETURN u.password",
        "RETURN version()"
      ]
    },
    {
      "name": "Denial of Service (DoS)",
      "description": "试图通过高复杂度查询耗尽服务器资源",
      "payloads": [
        "MATCH (a), (b), (c), (d) RETURN count(*)",
        "UNWIND range(1, 1000000) AS x RETURN x",
        "MATCH (n) WHERE n.name =~ '.*.*.*.*.*.*.*.*' RETURN n"
      ]
    },
    {
      "name": "APOC / Procedures Abuse",
      "description": "试图滥用 APOC 插件执行危险操作（如果已安装）",
      "payloads": [
        "CALL apoc.cypher.run('MATCH (n) DETACH DELETE n', {})",
        "CALL apoc.export.json.all('malicious_export.json', {})",
        "CALL apoc.trigger.add('malicious', 'RETURN 1', {})"
      ]
    }
  ]
}

```

---

### 2. 安全扫描器脚本 (security_scan.py)

此脚本模拟攻击者行为，尝试将 Payload 注入到 `ActionDriver` 的执行流程中。它会检查系统是否抛出了预期的异常，或者（更糟糕地）执行了恶意操作。

请保存为 `tests/security/scan_cypher_injection.py`。

```python
import json
import logging
import pytest
from pathlib import Path
from genesis.kernel.game_engine import GameEngine
from genesis.kernel.connectors.neo4j_connector import Neo4jConnector

# 配置日志
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger("SecurityScanner")

PAYLOAD_FILE = Path(__file__).parent / "security_payloads.json"

class SecurityScanner:
    def __init__(self):
        # 初始化一个测试用的临时环境
        self.engine = GameEngine(domain_path="domains/test_fixtures")
        self.engine.initialize_world()
        self.neo4j = Neo4jConnector()
        
    def load_payloads(self):
        with open(PAYLOAD_FILE, 'r', encoding='utf-8') as f:
            data = json.load(f)
        return data["categories"]

    def check_database_integrity(self):
        """检查数据库是否被破坏（例如节点数是否归零）"""
        result = self.neo4j.run_query("MATCH (n) RETURN count(n) as count")
        count = result[0]['count']
        return count > 0

    def inject_action_parameter(self, payload: str):
        """
        攻击向量 1: 参数注入
        模拟用户输入被恶意构造，试图突破 action_driver 的参数化防御
        """
        # 构造一个恶意的 Action 请求
        # 假设有一个 ACT_ATTACK 动作，我们需要 target_id 参数
        # 正常是 "npc_01"，攻击者输入 Payload
        action_id = "ACT_ATTACK"
        malicious_params = {
            "source_id": "player_1",
            "target_id": payload,  # 注入点
            "damage": 10
        }
        
        try:
            logger.debug(f"Testing Payload: {payload}")
            # 执行动作
            result = self.engine.action_driver.execute(action_id, malicious_params)
            return result
        except Exception as e:
            # 捕获异常通常是好事（说明执行失败了）
            return {"status": "error", "message": str(e)}

    def inject_forge_generator(self, payload: str):
        """
        攻击向量 2: Text-to-Cypher 生成注入
        (如果 Forge 有 AI 自动生成 Cypher 的接口)
        """
        # 模拟 AI 生成的 Cypher 包含了恶意指令（Prompt Injection 后果）
        # 这里我们直接测试 neo4j_connector 是否能拦截包含 DELETE 的读操作
        
        # 假设我们有一个只读的查询接口
        query = f"MATCH (n {{name: '{payload}'}}) RETURN n"
        
        # 检查是否使用了简单的字符串拼接（这是漏洞所在）
        # 如果系统正确使用了参数化查询，这里应该安全
        # 但我们这里模拟的是如果代码里有 unsafe_execute
        pass

@pytest.fixture(scope="module")
def scanner():
    return SecurityScanner()

def test_security_payloads(scanner):
    categories = scanner.load_payloads()
    
    total_payloads = 0
    blocked_payloads = 0
    
    initial_integrity = scanner.check_database_integrity()
    assert initial_integrity, "Database must not be empty before scan"

    for category in categories:
        logger.info(f"--- Scanning Category: {category['name']} ---")
        
        for payload in category["payloads"]:
            total_payloads += 1
            
            # 1. 执行注入
            result = scanner.inject_action_parameter(payload)
            
            # 2. 验证结果
            # 如果系统执行成功（status=success），说明 Payload 可能被当作普通字符串处理了（参数化查询生效），这是安全的。
            # 如果系统执行成功且数据库被清空了，那就是漏洞！
            
            current_integrity = scanner.check_database_integrity()
            
            if not current_integrity:
                pytest.fail(f"[CRITICAL] Data destruction detected! Payload: {payload}")
            
            # 检查是否有非法操作的迹象
            # 对于参数注入，Neo4j 应该把 payload 当作纯字符串。
            # 例如 target_id = "MATCH (n) DELETE n" -> 找不到 ID 为该字符串的节点 -> 验证失败。
            
            if result.get("success") is False:
                # 预期行为：验证失败（找不到恶意ID的节点）
                blocked_payloads += 1
            else:
                # 如果 Action 执行成功，我们需要确认它没有产生副作用
                # 比如 damage 是否被应用到了奇怪的地方？
                # 在此简化测试中，我们主要关注完整性
                pass
                
    logger.info(f"Security Scan Complete. Blocked/Safe: {blocked_payloads}/{total_payloads}")
    
    # 最终断言：扫描后数据库应该完好无损
    assert scanner.check_database_integrity(), "Database integrity compromised during scan!"


```

---

### 3. 增强防御能力 (Mitigation Strategy)

如果在扫描中发现漏洞，请在 `MyGame/genesis/kernel/connectors/neo4j_connector.py` 中应用以下防御措施。

#### 3.1 强制参数化查询 (Mandatory Parameterization)

**错误写法 (Vulnerable):**

```python
def execute_unsafe(self, query_template, params):
    # 危险！直接拼接字符串
    query = query_template.format(**params) 
    return self.session.run(query)

```

**正确写法 (Secure):**

```python
def execute_safe(self, query, params):
    # 安全：参数作为字典传递，Neo4j 驱动会自动处理转义
    return self.session.run(query, params)

```

#### 3.2 读写分离与只读事务 (Read-Only Enforcement)

在 `Validation` 阶段，强制使用只读事务，防止 `DELETE/SET` 操作。

```python
# MyGame/genesis/kernel/connectors/neo4j_connector.py

def run_cypher_validation(self, query: str, params: dict):
    """专门用于 Validation 的执行方法，强制只读"""
    with self.driver.session() as session:
        # 使用 read_transaction 模式，Neo4j 会拒绝写操作
        try:
            result = session.read_transaction(
                lambda tx: tx.run(query, params).data()
            )
            return result
        except Exception as e:
            if "Write operations are not allowed" in str(e):
                logger.warning(f"Intercepted malicious WRITE in validation: {query}")
                raise SecurityError("Write operations forbidden in validation phase")
            raise e

```

#### 3.3 关键词黑名单 (Keyword Sanitization)

针对 AI 生成的 Cypher（Text-to-Cypher），在执行前进行静态分析拦截。

```python
# MyGame/genesis/kernel/utils/security.py

import re

FORBIDDEN_PATTERNS = [
    r"\bDETACH\b",
    r"\bDELETE\b",
    r"\bDROP\b",
    r"\bCALL\b.*\bapoc\b", # 禁止直接调用 APOC
    r"\bLOAD CSV\b"        # 禁止加载外部文件
]

def validate_generated_cypher(query: str):
    """
    检查生成的 Cypher 是否包含高危指令
    注意：这不能替代参数化查询，仅作为第二道防线
    """
    normalized = query.upper()
    for pattern in FORBIDDEN_PATTERNS:
        if re.search(pattern, normalized):
            raise SecurityError(f"Malicious Cypher detected: matches {pattern}")
    return True

```